import "globals.act";
import "channel.act";

export defproc merge(globals g; e1of<2> A, B, R)
{
	bool _Rd0, _Rd1;
	bool Le;
	A.e = Le;
	B.e = Le;

	prs <g.Vdd, g.GND>
	{
		R.e & A.d[0] & B.d[0] -> _Rd0-
		R.e & A.d[1] -> _Rd1-
		~_Rd0 -> R.d[0]+
		~_Rd1 -> R.d[1]+

		R.d[0] | R.d[1] -> Le-

		~R.e & ~A.d[0] & ~B.d[0] -> _Rd0+
		~R.e & ~A.d[1] -> _Rd1+
		_Rd0 -> R.d[0]-
		_Rd1 -> R.d[1]-

		~R.d[0] & ~R.d[1] -> Le+
	}
}

export defproc source(globals g; e1of<2> C)
{
	bool Ca;
	prs<g.Vdd, g.GND>
	{
		g._sReset & C.e -> Ca-
		~g._sReset | ~C.e -> Ca+

		Ca -> C.d[0]-
		~Ca -> C.d[0]+

		Ca -> C.d[1]-
		~Ca -> C.d[1]+
	}

	spec {
		mk_exclhi(C.d[0], C.d[1])
	}
}

export defproc sink(globals g; e1of<2> C)
{
	prs <g.Vdd, g.GND>
	{
		C.d[0] | C.d[1] -> C.e-
		~C.d[0] & ~C.d[1] -> C.e+
	}
}

globals g;
e1of<2> A, B, R;
source source_A(g, A);
source source_B(g, B);
sink sink_R(g, R);
merge dut(g, A, B, R);

